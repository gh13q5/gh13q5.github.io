---
title: "게임 프로그래밍 패턴, 좋은 구조"
author: gh13
date: 2021-05-14 12:13:00 +0800
categories: [CS (Computer Science), 디자인 패턴]
tags: [디자인 패턴, 게임 프로그래밍 페탄, 기술 서적]
render_with_liquid: false
image:
  path: /assets/img/post_img/2023-12-22-01.png
---

> `게임 프로그래밍 패턴(w.로버트 나이스트롬, t.박일)`을 공부하며 작성한 메모를 한 번 더 정리한 게시글입니다.
{: .prompt-info }

## 소프트웨어의 '좋은 구조'

`좋은 구조`란 코드를 거의 건드리지 않고도 원하는 작업을 수행할 수 있는 구조로, 얼마나 쉽게 변경할 수 있느냐가 코드 설계의 평가 척도가 된다. 소프트웨어 구조의 핵심 목표는 프로그래머가 작업하기 전에 알아야 할 지식의 양을 최소한으로 줄이는 것. 즉, 다른 코드와의 결합도(커플링)를 최소화한 구조가 좋은 구조로 가는 지름길이다. 그리고, 확장성을 위해 보조 코드를 마구잡이로 붙이게 된다면 구조가 엉망이 되기 쉽다. **디커플링과 확장성, 두 가지를 유심히 생각하며 조율하자!**

> You Aren't Gonna Need It, **`YAGNI`**는 해당 기능이 정말로 필요하다고 느껴질 때까지 기능 추가는 미루자는 익스트림 프로그래밍(XP)의 원칙이다.
{: .prompt-tip }

<br/>

## 유연한 프로토타입과 구체화된 최적화

![프로젝트의 목표와 중요시할 점](/assets/img/post_img/2023-12-22-02.png){: width="972"}

성능을 어느 정도 포기하고 유연하고 빠르게 제작할 수 있는 프로토타입과 반대로, 최적화 기법은 코드 속 내용을 구체적으로 제한해 좋은 성능을 얻는 대신 유연함을 포기하게 된다. 

> **`C++ 템플릿`** <br/>
> 코드의 유연함에도 스펙트럼이 존재한다. <br/>
> 코드에서 클래스 메서드를 직접 호출한다면 클래스를 코드 작성 시점에 고정하게 된다. (하드코딩!) 반면, 가상 메서드나 인터페이스를 통해 호출하면 런타임에서 호출되는 클래스를 알 수 있지만, 성능 면에서 약간의 추가의 비용이 발생한다.  
> C++의 템플릿 메타프로그래밍은 컴파일 시점에 템플릿이 인스턴스화되면서 어떤 클래스가 호출될지 정해진다. 이는 런타임 낭비가 없는 인터페이스 추상화 방법이다.  
{: .prompt-tip }
